# 图


## 基本概念

### 有向图

### 无向图

### 简单图

- 不存在重复边

- 不存在顶点到自身的边

### 多重图

- 两顶点之间边数大于1

- 或存在顶点到自身的边

### 完全图

- 任意两顶点之间都存在边

### 子图

### 连通图

- 连通图

	- 任意两个点顶点都是连通的

- 连通

	- 无向图中 两顶点有路径存在

- 连通分量

	- 无向图中的极大连通子图

### 强连通

- 强连通图

	- 有向图任意两顶点都是强连通的

- 强连通

	- 有向图中，两顶点之间存在相互的路径

- 强连通分量

	- 有向图中最大强连通子图

### 生成树

- 连通图包含全部顶点的极小连通子图

### 生成森林

- 非连通图由连通分量的生成树构成的非连通子图

### 顶点度、入度、出度

- 度

	- 依附于指定顶点的数目

- 无向图

	- 全部度数的和等于2*顶点数目

- 有向图

	- 有向图全部顶点的入度和出度之和相等，等于边数

### 边的权和网

- 权

	- 图中每条边表上具有某种含义的数值

- 网

	- 边上有权值的图称为带权图

### 稠密图、稀疏图

### 路径

- 路径长度

	- 路径上边的数目

- 回路

	- 若图上有n个顶点，且有大于n-1条边，一定有回路

### 简单路径

- 顶点不重复出现的路径

### 简单回路

- 顶点不重复出现的回路

### 距离

- 若两顶点最短路径存在，则此路径长度为两点间距离，否则距离∞

### 有向树

- 一个顶点入度为0，其余顶点的入度为1的有向图

## 图的存储

### 邻接矩阵

- 定义

	- 用一个一维数组存储图中顶点的信息，用一个二维数组存储边的信息（顶点间的邻接关系），存储邻接关系的二维数组称为邻接矩阵

- 特点

	- 

		- 无向图的邻接矩阵是一个对称矩阵，存储时可采用压缩矩阵

	- 

		- 无向图中，第i行非零元素数量就是第i个顶点的度

	- 

		- 有向图中，第i行和第i列非零元素数量分别是第i个顶点的出度与入度

	- 

		- 稠密图适合使用邻接矩阵存储

	- 

		- 空间复杂度O(N^2)

### 邻接表

- 定义

	- 对图中每个顶点建立一个单链表，链表的节点表示与该顶点相连的边

- 特点

	- 

		- 顶点的数据和边表头结点指针采用顺序存储

	- 

		- 存储无向图空间复杂度O(|N|+|E|)，有向图空间复杂度O(|N|+2|E|)

	- 

		- 适合存储稀疏图

	- 

		- 通过邻接表很容易找到某顶点相邻的边，但是很难确定两顶点间是否存在边

	- 

		- 对于有向图，很容易求出某顶点出度，但是很难求出该顶点入度

	- 

		- 向同图，邻接表表示不唯一

### 十字链表（有向图）

- 定义

	- 一种有向图的链式存储结构

- 特点

	- 

		- 每个弧(有向边)对应一个弧节点，每个顶点对应一个顶点节点

		- 弧节点组成

			- 尾域

				- 指示弧尾顶点在图中的位置

			- 头域

				- 指示弧头顶点在图中的位置

			- 链域hlink

				- 指向弧头相同的下一条弧

			- 链域tlink

				- 指向弧尾相同的下一条弧

			- info域

				- 存储弧的相关信息(如权值）

		- 顶点节点组成

			- data域

				- 存放顶点的数据信息

			- firstin域

				- 存放以该节点为弧头的第一个弧节点

			- firstout域

				- 存放以该节点为弧尾的第一个弧节点

	- 

		- 顶点节点之间是顺序存储的

	- 

		- 很容找到以某顶点为头或尾的弧，也很容易得出该顶点的入度和出度

	- 

		- 图的十字链表表示不唯一，一个十字链表只能确定一个图

### 邻接多重表（无向图）

- 定义

	- 一种无向图的链式存储结构

- 为什么引入邻接多重表

	- 邻接表可以很容易求出顶点和边的信息，但是求两个顶点间是否存在边而对边删除时需要分别在两定点的边表中遍历，效率低

- 特点

	- 

		- 每条边用一个边节点表示，每个顶点也用一个顶点节点表示

		- 边节点

			- 标志域

			- ivex、jvex

				- 存储该边依附的两顶点在图中的位置

			- ilink、jlink

				- 分别指向下一条依附于ivex 和 jvex的边

			- info域

				- 存储边的相关信息

		- 顶点节点

			- data域

				- 存储顶点的数据信息

			- firstedge

				- 指向第一条依附于该节点的边

	- 

		- 所有依附于同一顶点的边串联在同一个链表，每个边节点同时链接在两个链表中

## 图的应用

### 最小生成(代价)树

- 概念

	- 最小生成树: 一个带权无向图边权值的和最小的生成树

- 性质

	- 最小生成树不唯一

	- 最小生成树边权值和唯一

	- 最小生成树边数为顶点数减一

- prim算法

	- 思想

		- 顶点优先

		- 开始时任选一个顶点加入树T,之后选择离T中顶点集合距离最近的顶点加入T,重复操作,直至所有的顶点都加入T

	- 分析

		- 时间复杂度O(|N|^2)

- Kruskal算法

	- 思想

		- 边优先

		- 初始时,每个顶点自成连通分量,按照边权值从小到大的顺序,选取未被选取过且权值最小的边,若边依附的顶点落在图的不同连通分量上,则将两点连通,否则舍弃

	- 分析

		- 采用堆存放边的集合

			- 时间复杂度O(log|E|)

		- 采用并查集描述生成树

			- 时间复杂度O(|E|log|E|)

		- 适用于描述边稀疏,顶点多的图

### 最短路径

- Dijkstra算法

	- 求单源最短路径

	- 不能求负权值的有向图

	- 思想

		- 设置一个集合S,记录已求得的最短路径的顶点,初始时,把源点v0放入S,集合每并入一个新顶点,都要修改v0到V-S中顶点当前的最短路径长度

	- 时间复杂度 O(|V|^2)

- Floyd算法

	- 求没对顶点间的最短路径

	- 不能解决带负权值回路的有向图

	- 思想

		- 基于动态规划思想,将问题分解为多个阶段,对于n个节点的图,求任意一对顶点Vi->Vj之间的最短路分为多个阶段,初始时不允许在其他路径中转,最短路径为?允许在v0中转,最短路径为?允许在v0,v1中转……不断更新最优解

	- 时间复杂度O(|V|^3)

### 有向无环图(DAG)图

- 一个不存在环的有向图

### 拓扑排序

- AOV网

	- 用DAG图表示一个工程,顶点表示活动,用有向边<Vi,Vj>表示活动Vi 必须先于活动Vj,则称这种图为AOV网(顶点表示活动的网络)

- 步骤

	- 

		- 从AOV网中选择一个没有前驱的顶点(入度为0)输出

	- 

		- 从网中删除该顶点和所有以它为起点的有向边

	- 

		- 重复1、2直至不存在无前驱的顶点或当前AOV网为空

	- 

		- 若最后仍剩下一些有前驱的节点，说明图中必有环

- 反拓扑排序

	- 重复输出和删除 出度为0的点以及指向它的弧

### 关键路径

- AOE网

	- 用顶点表示事件，用边表示活动，用边的权值表示活动开销的网称为AOE网(用边表示活动的网络)

- AOE网性质

	- 

		- 顶点代表的事件发生后，从该顶点出发的边表示的活动才能开始

	- 

		- 指向某顶点的所有边都结束后，该顶点代表的事件才能发生

- 关键路径定义

	- 从开始顶点到结束顶点的所有路径中,具有最大路径长度的路径

- 关键活动的定义

	- 关键路径上的活动

- 关键活动的参量定义

	- 事件Vk的最早发生之间 ve(i)

		- 从源点到Vk的最长路径长度

		- 可以通过正向拓扑排序计算

	- 事件Vk的最迟发生之间vl(i)

		- 保证后继事件vk在其最迟发生时间能够发生时,该事件必须发生的时间

		- 可以通过逆向拓扑排序计算

	- 活动ai的最早开始时间e(i)

		- 指该活动弧起点所表示的时间最早发生时间

	- 活动ai的最迟开始时间l(i)

		- 表示该活动弧终点表示的时间的最迟发生时间与该活动所需时间之差

	- 活动ai的最迟开始时间和最早开始时间的差额d(i) = l(i) - e(i)

		- 表示该活动完成的时间余量(该活动不增加工程总时间的情况下可以拖延的时间)

- 求关键路径算法步骤

	- 1.从源点出发,按拓扑,有序求其余各顶点的最早发生时间

	- 

		- 从汇点(终点)出发,按逆拓扑,有序求各顶点最迟发生之间

	- 

		- 根据各顶点最早发生时间求所有弧最早开始时间

	- 

		- 根据各顶点最迟发生时间,求所有弧最晚开始时间

	- 

		- 求AOE网中所有活动差额,找出d() = 0的关键路径

- 注意

	- 关键路径上所有活动都是关键活动,可通过加快关键活动缩短整个工程周期,但关键活动缩短到一定程度会变味非关键活动

	- 关键路径并不唯一,所以只提高一条关键路径无法缩短工程周期,只有加快在所有关键路径上的关键活动才能缩短工程周期

## 图的遍历

### BFS

- 思想

	- 类似于树的层序遍历

	- 访问起始顶点v，接着访问所有与v邻接的顶点，再从这些邻接顶点出发，访问他们邻接但未访问的过得顶点

- 分析

	- 需要借助辅助队列存储邻接节点，最坏空间复杂度O(|V|)

	- 时间复杂度

		- 以邻接矩阵表示，时间复杂度O(|V^2|)

		- 以邻接表表示，时间复杂度O(|V|+|E|)

- BFS生成树

	- 若图为非连通图，则会生成森林

	- 遍历的过程中，会得到一棵遍历树，图的邻接矩阵法对应的广度优先生成树唯一，邻接表法的存储表示不唯一，所以广度优先生成树也不唯一

### DFS

- 思想

	- 类似于树的先序遍历

	- 访问起始顶点v，从v出发，访问邻接且未被访问的顶点w1，在从w1出发，重复这个过程，直至无法向下，再回退到最近被访问的节点，看看是否还有其他邻接节点，重复这个过程

- 分析

	- DFS是一个递归算法，需要递归工作栈，空间复杂度O(|V|)

	- 时间复杂度

		- 以邻接矩阵表示，时间复杂度O(|V^2|)

		- 以邻接表表示，时间复杂度O(|V|+|E|)

- DFS生成树

	- 若图为非连通图，则会生成森林

	- 图的邻接矩阵法对应的深度优先生成树唯一，邻接表法的存储表示不唯一，所以深度优先生成树也不唯一

